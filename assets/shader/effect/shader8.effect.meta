{
  "ver": "1.0.27",
  "uuid": "ccef7751-4fa8-4887-adeb-acade09cca24",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\nfloat merge(float d1, float d2)\n{\n  return min(d1, d2);\n}\nfloat mergeExclude(float d1, float d2)\n{\n  return min(max(-d1, d2), max(-d2, d1));\n}\nfloat substract(float d1, float d2)\n{\n  return max(-d1, d2);\n}\nfloat intersect(float d1, float d2)\n{\n  return max(d1, d2);\n}\nvec2 rotateCW(vec2 p, float a)\n{\n  mat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n  return p * m;\n}\nvec2 translate(vec2 p, vec2 t)\n{\n  return p - t;\n}\nfloat pie(vec2 p, float angle)\n{\n  angle = radians(angle) / 2.0;\n  vec2 n = vec2(cos(angle), sin(angle));\n  return abs(p).x * n.x + p.y*n.y;\n}\nfloat circleDist(vec2 p, float radius)\n{\n  return length(p) - radius;\n}\nfloat triangleDist(vec2 p, float radius)\n{\n  return max(  abs(p).x * 0.866025 +\n          p.y * 0.5, -p.y)\n        -radius * 0.5;\n}\nfloat triangleDist(vec2 p, float width, float height)\n{\n  vec2 n = normalize(vec2(height, width / 2.0));\n  return max(  abs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n  width /= 2.0;\n  radius -= width;\n  return substract(pie(p, angle),\n          abs(circleDist(p, radius)) - width);\n}\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  size -= vec2(radius);\n  vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n  vec2 dir = start - end;\n  float lngth = length(dir);\n  dir /= lngth;\n  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n  return length( (start - p) - proj ) - (width / 2.0);\n}\nfloat fillMask(float dist)\n{\n  return clamp(-dist, 0.0, 1.0);\n}\nfloat innerBorderMask(float dist, float width)\n{\n  float alpha1 = clamp(dist + width, 0.0, 1.0);\n  float alpha2 = clamp(dist, 0.0, 1.0);\n  return alpha1 - alpha2;\n}\nfloat sceneDist(vec2 p)\n{\n  float c = circleDist(    translate(p, vec2(100, 250)), 40.0);\n  float b1 =  boxDist(    translate(p, vec2(200, 250)), vec2(40, 40),   0.0);\n  float b2 =  boxDist(    translate(p, vec2(300, 250)), vec2(40, 40),   10.0);\n  float l = lineDist(      p,        vec2(370, 220),  vec2(430, 280),  10.0);\n  float t1 = triangleDist(  translate(p, vec2(500, 210)), 80.0,       80.0);\n  float t2 = triangleDist(  rotateCW(translate(p, vec2(600, 250)), cc_time.x), 40.0);\n  float m =   merge(c, b1);\n  m =     merge(m, b2);\n  m =     merge(m, l);\n  m =     merge(m, t1);\n  m =     merge(m, t2);\n  float b3 = boxDist(    translate(p, vec2(100, sin(cc_time.x * 3.0 + 1.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c2 = circleDist(  translate(p, vec2(100, 100)),  30.0);\n  float s = substract(b3, c2);\n  float b4 = boxDist(    translate(p, vec2(200, sin(cc_time.x * 3.0 + 2.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c3 = circleDist(  translate(p, vec2(200, 100)),   30.0);\n  float i = intersect(b4, c3);\n  float b5 = boxDist(    translate(p, vec2(300, sin(cc_time.x * 3.0 + 3.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c4 = circleDist(  translate(p, vec2(300, 100)),   30.0);\n  float a = merge(b5, c4);\n  float b6 = boxDist(    translate(p, vec2(400, 100)),  vec2(40, 15),   0.0);\n  float c5 = circleDist(  translate(p, vec2(400, 100)),   30.0);\n  float sm = smoothMerge(b6, c5, 10.0);\n  float sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    float b7 = boxDist(    translate(p, vec2(600, sin(cc_time.x * 3.0 + 3.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c6 = circleDist(  translate(p, vec2(600, 100)),   30.0);\n  float e = mergeExclude(b7, c6);\n  m = merge(m, s);\n  m = merge(m, i);\n  m = merge(m, a);\n  m = merge(m, sm);\n  m = merge(m, sc);\n    m = merge(m, e);\n  return m;\n}\nfloat sceneSmooth(vec2 p, float r)\n{\n  float accum = sceneDist(p);\n  accum += sceneDist(p + vec2(0.0, r));\n  accum += sceneDist(p + vec2(0.0, -r));\n  accum += sceneDist(p + vec2(r, 0.0));\n  accum += sceneDist(p + vec2(-r, 0.0));\n  return accum / 5.0;\n}\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n  vec2 dir = normalize(pos - p);\n  float dl = length(p - pos);\n  float lf = radius * dl;\n  float dt = 0.01;\n  for (int i = 0; i < 64; ++i)\n  {\n    float sd = sceneDist(p + dir * dt);\n        if (sd < -radius)\n            return 0.0;\n    lf = min(lf, sd / dt);\n    dt += max(1.0, abs(sd));\n    if (dt > dl) break;\n  }\n  lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n  lf = smoothstep(0.0, 1.0, lf);\n  return lf;\n}\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n  float ld = length(p - pos);\n  if (ld > range) return vec4(0.0);\n  float shad = shadow(p, pos, radius);\n  float fall = (range - ld)/range;\n  fall *= fall;\n  float source = fillMask(circleDist(p - pos, radius));\n  return (shad * fall + source) * color;\n}\nfloat luminance(vec4 col)\n{\n  return 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\nvoid setLuminance(inout vec4 col, float lum)\n{\n  lum /= luminance(col);\n  col *= lum;\n}\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n  float a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n  return 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n  return smoothstep(0.0, 1.0, dist / radius);\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  vec2 p = gl_FragCoord.xy + vec2(0.5);\n  vec2 c = vec2(960.0,640.0).xy / 2.0;\n  float dist = sceneDist(p);\n  vec2 light1Pos = vec2(0.7);\n  vec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n  setLuminance(light1Col, 0.4);\n  vec2 light2Pos = vec2(vec2(960.0,640.0).x * (sin(cc_time.x + 3.1415) + 1.2) / 2.4, 175.0);\n  vec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n  setLuminance(light2Col, 0.5);\n  vec2 light3Pos = vec2(vec2(960.0,640.0).x * (sin(cc_time.x) + 1.2) / 2.4, 340.0);\n  vec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n  setLuminance(light3Col, 0.6);\n  vec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/vec2(960.0,640.0).x);\n  col *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n  col *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n  col += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n  col += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n  col += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n  col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n  col = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n  gl_FragColor = clamp(col, 0.0, 1.0);\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\nfloat merge(float d1, float d2)\n{\n  return min(d1, d2);\n}\nfloat mergeExclude(float d1, float d2)\n{\n  return min(max(-d1, d2), max(-d2, d1));\n}\nfloat substract(float d1, float d2)\n{\n  return max(-d1, d2);\n}\nfloat intersect(float d1, float d2)\n{\n  return max(d1, d2);\n}\nvec2 rotateCW(vec2 p, float a)\n{\n  mat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n  return p * m;\n}\nvec2 translate(vec2 p, vec2 t)\n{\n  return p - t;\n}\nfloat pie(vec2 p, float angle)\n{\n  angle = radians(angle) / 2.0;\n  vec2 n = vec2(cos(angle), sin(angle));\n  return abs(p).x * n.x + p.y*n.y;\n}\nfloat circleDist(vec2 p, float radius)\n{\n  return length(p) - radius;\n}\nfloat triangleDist(vec2 p, float radius)\n{\n  return max(  abs(p).x * 0.866025 +\n          p.y * 0.5, -p.y)\n        -radius * 0.5;\n}\nfloat triangleDist(vec2 p, float width, float height)\n{\n  vec2 n = normalize(vec2(height, width / 2.0));\n  return max(  abs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n  width /= 2.0;\n  radius -= width;\n  return substract(pie(p, angle),\n          abs(circleDist(p, radius)) - width);\n}\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  size -= vec2(radius);\n  vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n  vec2 dir = start - end;\n  float lngth = length(dir);\n  dir /= lngth;\n  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n  return length( (start - p) - proj ) - (width / 2.0);\n}\nfloat fillMask(float dist)\n{\n  return clamp(-dist, 0.0, 1.0);\n}\nfloat innerBorderMask(float dist, float width)\n{\n  float alpha1 = clamp(dist + width, 0.0, 1.0);\n  float alpha2 = clamp(dist, 0.0, 1.0);\n  return alpha1 - alpha2;\n}\nfloat sceneDist(vec2 p)\n{\n  float c = circleDist(    translate(p, vec2(100, 250)), 40.0);\n  float b1 =  boxDist(    translate(p, vec2(200, 250)), vec2(40, 40),   0.0);\n  float b2 =  boxDist(    translate(p, vec2(300, 250)), vec2(40, 40),   10.0);\n  float l = lineDist(      p,        vec2(370, 220),  vec2(430, 280),  10.0);\n  float t1 = triangleDist(  translate(p, vec2(500, 210)), 80.0,       80.0);\n  float t2 = triangleDist(  rotateCW(translate(p, vec2(600, 250)), cc_time.x), 40.0);\n  float m =   merge(c, b1);\n  m =     merge(m, b2);\n  m =     merge(m, l);\n  m =     merge(m, t1);\n  m =     merge(m, t2);\n  float b3 = boxDist(    translate(p, vec2(100, sin(cc_time.x * 3.0 + 1.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c2 = circleDist(  translate(p, vec2(100, 100)),  30.0);\n  float s = substract(b3, c2);\n  float b4 = boxDist(    translate(p, vec2(200, sin(cc_time.x * 3.0 + 2.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c3 = circleDist(  translate(p, vec2(200, 100)),   30.0);\n  float i = intersect(b4, c3);\n  float b5 = boxDist(    translate(p, vec2(300, sin(cc_time.x * 3.0 + 3.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c4 = circleDist(  translate(p, vec2(300, 100)),   30.0);\n  float a = merge(b5, c4);\n  float b6 = boxDist(    translate(p, vec2(400, 100)),  vec2(40, 15),   0.0);\n  float c5 = circleDist(  translate(p, vec2(400, 100)),   30.0);\n  float sm = smoothMerge(b6, c5, 10.0);\n  float sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    float b7 = boxDist(    translate(p, vec2(600, sin(cc_time.x * 3.0 + 3.0) * 40.0 + 100.0)),\n                vec2(40, 15),   0.0);\n  float c6 = circleDist(  translate(p, vec2(600, 100)),   30.0);\n  float e = mergeExclude(b7, c6);\n  m = merge(m, s);\n  m = merge(m, i);\n  m = merge(m, a);\n  m = merge(m, sm);\n  m = merge(m, sc);\n    m = merge(m, e);\n  return m;\n}\nfloat sceneSmooth(vec2 p, float r)\n{\n  float accum = sceneDist(p);\n  accum += sceneDist(p + vec2(0.0, r));\n  accum += sceneDist(p + vec2(0.0, -r));\n  accum += sceneDist(p + vec2(r, 0.0));\n  accum += sceneDist(p + vec2(-r, 0.0));\n  return accum / 5.0;\n}\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n  vec2 dir = normalize(pos - p);\n  float dl = length(p - pos);\n  float lf = radius * dl;\n  float dt = 0.01;\n  for (int i = 0; i < 64; ++i)\n  {\n    float sd = sceneDist(p + dir * dt);\n        if (sd < -radius)\n            return 0.0;\n    lf = min(lf, sd / dt);\n    dt += max(1.0, abs(sd));\n    if (dt > dl) break;\n  }\n  lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n  lf = smoothstep(0.0, 1.0, lf);\n  return lf;\n}\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n  float ld = length(p - pos);\n  if (ld > range) return vec4(0.0);\n  float shad = shadow(p, pos, radius);\n  float fall = (range - ld)/range;\n  fall *= fall;\n  float source = fillMask(circleDist(p - pos, radius));\n  return (shad * fall + source) * color;\n}\nfloat luminance(vec4 col)\n{\n  return 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\nvoid setLuminance(inout vec4 col, float lum)\n{\n  lum /= luminance(col);\n  col *= lum;\n}\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n  float a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n  return 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n  return smoothstep(0.0, 1.0, dist / radius);\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  vec2 p = gl_FragCoord.xy + vec2(0.5);\n  vec2 c = vec2(960.0,640.0).xy / 2.0;\n  float dist = sceneDist(p);\n  vec2 light1Pos = vec2(0.7);\n  vec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n  setLuminance(light1Col, 0.4);\n  vec2 light2Pos = vec2(vec2(960.0,640.0).x * (sin(cc_time.x + 3.1415) + 1.2) / 2.4, 175.0);\n  vec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n  setLuminance(light2Col, 0.5);\n  vec2 light3Pos = vec2(vec2(960.0,640.0).x * (sin(cc_time.x) + 1.2) / 2.4, 340.0);\n  vec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n  setLuminance(light3Col, 0.6);\n  vec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/vec2(960.0,640.0).x);\n  col *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n  col *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n  col += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n  col += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n  col += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n  col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n  col = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n  gl_FragColor = clamp(col, 0.0, 1.0);\n}"
      }
    }
  ],
  "subMetas": {}
}