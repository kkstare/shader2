{
  "ver": "1.0.27",
  "uuid": "6a2084e7-aa77-4543-9537-a8868188fbb4",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  vec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture2D(texture, uv*.125).r*.5;\n    f += texture2D(texture, uv*.25).r*.25;\n    f += texture2D(texture, uv*.5).r*.125;\n    f += texture2D(texture, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\nfloat hash2d (vec2 st)\n{return fract(sin(dot(st,vec2(2.445,8.55)))*4.4541);}\nfloat hash (float x)\n{return fract(sin(x)*14.4545);}\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*3.141592/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor((a-per*0.5)/per);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep/2.) id = abs(id);\n    return id;\n}\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\nfloat water (vec3 p)\n{\n  vec3 pp = p;\n  float s= sphe (p, 3.);\n  float b = box(p+vec3(0.,.6,0.), vec3(5.,0.5,5.));\n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.8, 10.);\n  p = pp;\n  p.y += sin(length(p.xz*4.)-cc_time.x*2.)*0.1;\n  return max(-b,max(-c,max(s,abs(p.y+2.)-3.)));\n}\nfloat waterfall (vec3 p)\n{\n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.4+sin(p.y*0.15), 3.);\n  return c;\n}\nfloat gem (vec3 p)\n{\n    p.y -= 3.;\n    p.xz*=rot(cc_time.x);\n    float o = od(p, 1.2);\n    return o;\n}\nfloat inside_gem (vec3 p)\n{\n  p.y += 0.5;\n  float o = od(p,0.5);\n  return o;\n}\nvec3 cyl_grid_ids;\nfloat cyl_grid (vec3 p)\n{\n  p.z += sin(p.y+cc_time.x);\n  vec3 per = vec3(0.3,2.,0.3);\n  cyl_grid_ids = floor((p-per*0.5)/per);\n  p.y -= hash2d(cyl_grid_ids.xz)+cc_time.x;\n  p = mod(p-per*0.5, per)-per*0.5;\n  p.x -= sin(p.y*5.+cc_time.x)*0.1;\n  return cyl(p.xzy, 0.1, 0.8);\n}\nint mat = 0;\nfloat SDF (vec3 p)\n{\n  p.y += texNoise(p.xz).x*0.8;\n  float g = gem(p);\n  float ig = inside_gem(p);\n  float w = water(p);\n  float wf = waterfall(p);\n  float d = smin(g,min(ig,min(w, wf)), 0.2);\n  if (d == w) mat=1;\n  if (d == wf) mat=2;\n  if (d == g || d == ig) mat=3;\n  d = max(cyl_grid(p), d);\n  return d;\n}\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv, float fov)\n{\n  vec3 forward = normalize(tar-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.),forward));\n  vec3 up = normalize(cross(forward, left));\n  return normalize(forward * fov + left * uv.x + up * uv.y);\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n  vec2 inuv = v_uv0;\n   vec2 uv = vec2(gl_FragCoord.x / vec2(960.0,640.0).x, gl_FragCoord.y / vec2(960.0,640.0).y);\n  uv -= 0.5;\n  uv /= vec2(vec2(960.0,640.0).y / vec2(960.0,640.0).x, 1);\n  float dither = hash2d(uv);\n  vec3 ro = vec3(0.01,3.,-10.); vec3 p = ro;\n  vec3 tar = vec3(0.,1.,0.);\n  vec3 rd = getcam(ro, tar, uv, 1.);\n  vec3 col = vec3(0.);\n  bool hit = false;\n  float shad = 0.;\n  for (float i=0.; i<100.; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      shad = i/100.;\n      break;\n    }\n    d *= 0.9+dither*0.2;\n    p += d*rd;\n  }\n  if (hit)\n  {\n    if (mat == 1) col = vec3(hash(cyl_grid_ids.x)*0.5, hash(cyl_grid_ids.z), 1.);\n    if (mat == 2) col = vec3(hash(cyl_grid_ids.z), 1., hash(cyl_grid_ids.x));\n    if (mat == 3) col = vec3(1., hash(cyl_grid_ids.z),hash(cyl_grid_ids.x)*0.3);;\n   }\n   else col = vec3(1.);\n  vec2 q = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n  col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.3);\n  gl_FragColor = vec4(pow(col,vec3(0.4545)),1.);\n  }"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n  vec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture2D(texture, uv*.125).r*.5;\n    f += texture2D(texture, uv*.25).r*.25;\n    f += texture2D(texture, uv*.5).r*.125;\n    f += texture2D(texture, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\nfloat hash2d (vec2 st)\n{return fract(sin(dot(st,vec2(2.445,8.55)))*4.4541);}\nfloat hash (float x)\n{return fract(sin(x)*14.4545);}\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*3.141592/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor((a-per*0.5)/per);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep/2.) id = abs(id);\n    return id;\n}\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\nfloat water (vec3 p)\n{\n  vec3 pp = p;\n  float s= sphe (p, 3.);\n  float b = box(p+vec3(0.,.6,0.), vec3(5.,0.5,5.));\n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.8, 10.);\n  p = pp;\n  p.y += sin(length(p.xz*4.)-cc_time.x*2.)*0.1;\n  return max(-b,max(-c,max(s,abs(p.y+2.)-3.)));\n}\nfloat waterfall (vec3 p)\n{\n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.4+sin(p.y*0.15), 3.);\n  return c;\n}\nfloat gem (vec3 p)\n{\n    p.y -= 3.;\n    p.xz*=rot(cc_time.x);\n    float o = od(p, 1.2);\n    return o;\n}\nfloat inside_gem (vec3 p)\n{\n  p.y += 0.5;\n  float o = od(p,0.5);\n  return o;\n}\nvec3 cyl_grid_ids;\nfloat cyl_grid (vec3 p)\n{\n  p.z += sin(p.y+cc_time.x);\n  vec3 per = vec3(0.3,2.,0.3);\n  cyl_grid_ids = floor((p-per*0.5)/per);\n  p.y -= hash2d(cyl_grid_ids.xz)+cc_time.x;\n  p = mod(p-per*0.5, per)-per*0.5;\n  p.x -= sin(p.y*5.+cc_time.x)*0.1;\n  return cyl(p.xzy, 0.1, 0.8);\n}\nint mat = 0;\nfloat SDF (vec3 p)\n{\n  p.y += texNoise(p.xz).x*0.8;\n  float g = gem(p);\n  float ig = inside_gem(p);\n  float w = water(p);\n  float wf = waterfall(p);\n  float d = smin(g,min(ig,min(w, wf)), 0.2);\n  if (d == w) mat=1;\n  if (d == wf) mat=2;\n  if (d == g || d == ig) mat=3;\n  d = max(cyl_grid(p), d);\n  return d;\n}\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv, float fov)\n{\n  vec3 forward = normalize(tar-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.),forward));\n  vec3 up = normalize(cross(forward, left));\n  return normalize(forward * fov + left * uv.x + up * uv.y);\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n  vec2 inuv = v_uv0;\n   vec2 uv = vec2(gl_FragCoord.x / vec2(960.0,640.0).x, gl_FragCoord.y / vec2(960.0,640.0).y);\n  uv -= 0.5;\n  uv /= vec2(vec2(960.0,640.0).y / vec2(960.0,640.0).x, 1);\n  float dither = hash2d(uv);\n  vec3 ro = vec3(0.01,3.,-10.); vec3 p = ro;\n  vec3 tar = vec3(0.,1.,0.);\n  vec3 rd = getcam(ro, tar, uv, 1.);\n  vec3 col = vec3(0.);\n  bool hit = false;\n  float shad = 0.;\n  for (float i=0.; i<100.; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      shad = i/100.;\n      break;\n    }\n    d *= 0.9+dither*0.2;\n    p += d*rd;\n  }\n  if (hit)\n  {\n    if (mat == 1) col = vec3(hash(cyl_grid_ids.x)*0.5, hash(cyl_grid_ids.z), 1.);\n    if (mat == 2) col = vec3(hash(cyl_grid_ids.z), 1., hash(cyl_grid_ids.x));\n    if (mat == 3) col = vec3(1., hash(cyl_grid_ids.z),hash(cyl_grid_ids.x)*0.3);;\n   }\n   else col = vec3(1.);\n  vec2 q = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n  col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.3);\n  gl_FragColor = vec4(pow(col,vec3(0.4545)),1.);\n  }"
      }
    }
  ],
  "subMetas": {}
}