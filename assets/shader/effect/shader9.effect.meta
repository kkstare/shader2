{
  "ver": "1.0.25",
  "uuid": "78d36bf2-34ae-4971-869d-82fb9b36b20a",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\n    varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\nconst mat2 mr = mat2 (0.84147,  0.54030,\n            0.54030, -0.84147 );\nfloat hash( float n ) {\n  return fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n  return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\nvec2 hash2( vec2 n ) {\n  return fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\n}\nvec3 hash3( float n ) {\n  return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nvec3 hash3( vec2 n ) {\n  return fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\n  if (rd.y==0.0) {\n    return false;\n  }\n  float d = -(ro.y - height)/rd.y;\n  d = min(100000.0, d);\n  if( d > 0. ) {\n    dist = d;\n    return true;\n  }\n  return false;\n}\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\n  vec3  ds = ro - sph;\n  float bs = dot( rd, ds );\n  float cs = dot(  ds, ds ) - 1.0;\n  float ts = bs*bs - cs;\n  if( ts > 0.0 ) {\n    ts = -bs - sqrt( ts );\n    if( ts>0. ) {\n      normal = normalize( (ro+ts*rd)-sph );\n      dist = ts;\n      return true;\n    }\n  }\n  return false;\n}\nvoid getSphereOffset( vec2 grid, inout vec2 center ) {\n  center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(5.);\n}\nvoid getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n  float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n  float t = fract(14.*s + cc_time.x/s*.3);\n  float y =  s * 30. * abs( 4.*t*(1.-t) );\n  vec2 offset = grid + sphereOffset;\n  center = vec3( offset.x, y, offset.y ) + 0.5*vec3( 8., 2., 8. );\n}\nvoid getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n  vec2 offset = grid + sphereOffset;\n  center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( 8., 2., 8. );\n}\nvec3 getSphereColor( vec2 grid ) {\n  return normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\n}\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n  material = 0;\n  dist = 400.;\n  float distcheck;\n  vec3 sphereCenter, col, normalcheck;\n  if( intersectPlane( ro,  rd, 0., distcheck) && distcheck < 400. ) {\n    dist = distcheck;\n    material = 1;\n    normal = vec3( 0., 1., 0. );\n    col = vec3( 0.25 );\n  } else {\n    col = vec3( 0. );\n  }\n  vec3 pos = floor(ro/8.)*8.;\n  vec3 ri = 1.0/rd;\n  vec3 rs = sign(rd) * 8.;\n  vec3 dis = (pos-ro + 0.5  * 8. + rs*0.5) * ri;\n  vec3 mm = vec3(0.0);\n  vec2 offset;\n  for( int i=0; i<40; i++ )  {\n    if( material > 1 || distance( ro.xz, pos.xz ) > dist+8. ) break;\n    vec2 offset;\n    getSphereOffset( pos.xz, offset );\n    getMovingSpherePosition( pos.xz, -offset, sphereCenter );\n    if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n      dist = distcheck;\n      normal = normalcheck;\n      material = 2;\n    }\n    getSpherePosition( pos.xz, offset, sphereCenter );\n    if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n      dist = distcheck;\n      normal = normalcheck;\n      col = getSphereColor( offset );\n      material = 3;\n    }\n    mm = step(dis.xyz, dis.zyx);\n    dis += mm * rs * ri;\n    pos += mm * rs;\n  }\n  vec3 color = vec3( 0. );\n  if( material > 0 ) {\n    intersection = ro + rd*dist;\n    vec2 map = floor(intersection.xz/8.)*8.;\n    if( material == 1 || material == 3 ) {\n      vec3 c = vec3( -8.,0., 8. );\n      for( int x=0; x<3; x++ ) {\n        for( int y=0; y<3; y++ ) {\n          vec2 mapoffset = map+vec2( c[x], c[y] );\n          vec2 offset;\n          getSphereOffset( mapoffset, offset );\n          vec3 lcolor = getSphereColor( mapoffset );\n          vec3 lpos;\n          getMovingSpherePosition( mapoffset, -offset, lpos );\n          float shadow = 1.;\n  #if SHADOW\n            if( material == 1 ) {\n              for( int sx=0; sx<3; sx++ ) {\n                for( int sy=0; sy<3; sy++ ) {\n                  if( shadow < 1. ) continue;\n                  vec2 smapoffset = map+vec2( c[sx], c[sy] );\n                  vec2 soffset;\n                  getSphereOffset( smapoffset, soffset );\n                  vec3 slpos, sn;\n                  getSpherePosition( smapoffset, soffset, slpos );\n                  float sd;\n                  if( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\n                    shadow = 0.;\n                  }\n                }\n              }\n            }\n  #endif\n          color += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\n                       clamp(10. / dot( lpos - intersection, lpos - intersection) - 0.075, 0., 1.)  );\n        }\n      }\n    } else {\n      color = (3.+2.*dot(normal, vec3( 0.5, 0.5, -0.5))) * getSphereColor( map );\n    }\n  }\n  return color;\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n  vec2 q = gl_FragCoord.xy/vec2(960.0,640.0).xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n  vec3 ce = vec3( cos( 0.232*cc_time.x) * 10., 6.+3.*cos(0.3*cc_time.x), 8.*(cc_time.x/0.5) );\n  vec3 ro = ce;\n  vec3 ta = ro + vec3( -sin( 0.232*cc_time.x) * 10., -2.0+cos(0.23*cc_time.x), 10.0 );\n  float roll = -0.15*sin(0.5*cc_time.x);\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( sin(roll), cos(roll),0.0 );\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n  int material;\n  vec3 normal, intersection;\n  float dist;\n  vec3 col = trace(ro, rd, intersection, normal, dist, material);\n#if REFLECTION\n  if( material > 0 ) {\n      float f = 0.04 * clamp(pow(1. + dot(rd, normal), 5.), 0., 1.);\n    vec3 ro = intersection + 0.0001*normal;\n    rd = reflect( rd, normal );\n    vec3 refColor = trace(ro, rd, intersection, normal, dist, material);\n    if (material > 2) {\n        col += .5 * refColor;\n    } else {\n        col += f * refColor;\n    }\n  }\n#endif\n  col = pow( col * .5, vec3(1./2.2) );\n  col = clamp(col, 0.0, 1.0);\n  col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n  gl_FragColor = vec4( col,1.0);\n  }"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n    in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\nconst mat2 mr = mat2 (0.84147,  0.54030,\n            0.54030, -0.84147 );\nfloat hash( float n ) {\n  return fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n  return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\nvec2 hash2( vec2 n ) {\n  return fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\n}\nvec3 hash3( float n ) {\n  return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nvec3 hash3( vec2 n ) {\n  return fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\n  if (rd.y==0.0) {\n    return false;\n  }\n  float d = -(ro.y - height)/rd.y;\n  d = min(100000.0, d);\n  if( d > 0. ) {\n    dist = d;\n    return true;\n  }\n  return false;\n}\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\n  vec3  ds = ro - sph;\n  float bs = dot( rd, ds );\n  float cs = dot(  ds, ds ) - 1.0;\n  float ts = bs*bs - cs;\n  if( ts > 0.0 ) {\n    ts = -bs - sqrt( ts );\n    if( ts>0. ) {\n      normal = normalize( (ro+ts*rd)-sph );\n      dist = ts;\n      return true;\n    }\n  }\n  return false;\n}\nvoid getSphereOffset( vec2 grid, inout vec2 center ) {\n  center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(5.);\n}\nvoid getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n  float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n  float t = fract(14.*s + cc_time.x/s*.3);\n  float y =  s * 30. * abs( 4.*t*(1.-t) );\n  vec2 offset = grid + sphereOffset;\n  center = vec3( offset.x, y, offset.y ) + 0.5*vec3( 8., 2., 8. );\n}\nvoid getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n  vec2 offset = grid + sphereOffset;\n  center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( 8., 2., 8. );\n}\nvec3 getSphereColor( vec2 grid ) {\n  return normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\n}\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n  material = 0;\n  dist = 400.;\n  float distcheck;\n  vec3 sphereCenter, col, normalcheck;\n  if( intersectPlane( ro,  rd, 0., distcheck) && distcheck < 400. ) {\n    dist = distcheck;\n    material = 1;\n    normal = vec3( 0., 1., 0. );\n    col = vec3( 0.25 );\n  } else {\n    col = vec3( 0. );\n  }\n  vec3 pos = floor(ro/8.)*8.;\n  vec3 ri = 1.0/rd;\n  vec3 rs = sign(rd) * 8.;\n  vec3 dis = (pos-ro + 0.5  * 8. + rs*0.5) * ri;\n  vec3 mm = vec3(0.0);\n  vec2 offset;\n  for( int i=0; i<40; i++ )  {\n    if( material > 1 || distance( ro.xz, pos.xz ) > dist+8. ) break;\n    vec2 offset;\n    getSphereOffset( pos.xz, offset );\n    getMovingSpherePosition( pos.xz, -offset, sphereCenter );\n    if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n      dist = distcheck;\n      normal = normalcheck;\n      material = 2;\n    }\n    getSpherePosition( pos.xz, offset, sphereCenter );\n    if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n      dist = distcheck;\n      normal = normalcheck;\n      col = getSphereColor( offset );\n      material = 3;\n    }\n    mm = step(dis.xyz, dis.zyx);\n    dis += mm * rs * ri;\n    pos += mm * rs;\n  }\n  vec3 color = vec3( 0. );\n  if( material > 0 ) {\n    intersection = ro + rd*dist;\n    vec2 map = floor(intersection.xz/8.)*8.;\n    if( material == 1 || material == 3 ) {\n      vec3 c = vec3( -8.,0., 8. );\n      for( int x=0; x<3; x++ ) {\n        for( int y=0; y<3; y++ ) {\n          vec2 mapoffset = map+vec2( c[x], c[y] );\n          vec2 offset;\n          getSphereOffset( mapoffset, offset );\n          vec3 lcolor = getSphereColor( mapoffset );\n          vec3 lpos;\n          getMovingSpherePosition( mapoffset, -offset, lpos );\n          float shadow = 1.;\n  #if SHADOW\n            if( material == 1 ) {\n              for( int sx=0; sx<3; sx++ ) {\n                for( int sy=0; sy<3; sy++ ) {\n                  if( shadow < 1. ) continue;\n                  vec2 smapoffset = map+vec2( c[sx], c[sy] );\n                  vec2 soffset;\n                  getSphereOffset( smapoffset, soffset );\n                  vec3 slpos, sn;\n                  getSpherePosition( smapoffset, soffset, slpos );\n                  float sd;\n                  if( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\n                    shadow = 0.;\n                  }\n                }\n              }\n            }\n  #endif\n          color += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\n                       clamp(10. / dot( lpos - intersection, lpos - intersection) - 0.075, 0., 1.)  );\n        }\n      }\n    } else {\n      color = (3.+2.*dot(normal, vec3( 0.5, 0.5, -0.5))) * getSphereColor( map );\n    }\n  }\n  return color;\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n  vec4 texture_tmp = texture(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n    #endif\n  vec2 q = gl_FragCoord.xy/vec2(960.0,640.0).xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n  vec3 ce = vec3( cos( 0.232*cc_time.x) * 10., 6.+3.*cos(0.3*cc_time.x), 8.*(cc_time.x/0.5) );\n  vec3 ro = ce;\n  vec3 ta = ro + vec3( -sin( 0.232*cc_time.x) * 10., -2.0+cos(0.23*cc_time.x), 10.0 );\n  float roll = -0.15*sin(0.5*cc_time.x);\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( sin(roll), cos(roll),0.0 );\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n  int material;\n  vec3 normal, intersection;\n  float dist;\n  vec3 col = trace(ro, rd, intersection, normal, dist, material);\n#if REFLECTION\n  if( material > 0 ) {\n      float f = 0.04 * clamp(pow(1. + dot(rd, normal), 5.), 0., 1.);\n    vec3 ro = intersection + 0.0001*normal;\n    rd = reflect( rd, normal );\n    vec3 refColor = trace(ro, rd, intersection, normal, dist, material);\n    if (material > 2) {\n        col += .5 * refColor;\n    } else {\n        col += f * refColor;\n    }\n  }\n#endif\n  col = pow( col * .5, vec3(1./2.2) );\n  col = clamp(col, 0.0, 1.0);\n  col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n  gl_FragColor = vec4( col,1.0);\n  }"
      }
    }
  ],
  "subMetas": {}
}