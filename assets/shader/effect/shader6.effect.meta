{
  "ver": "1.0.25",
  "uuid": "8c8e72b9-9e90-4407-872f-20fefa3fe5a4",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\nfloat freqs[4];\n#if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture1;\n  uniform sampler2D texture2;\n#endif\nfloat snoise(vec3 uv, float res)\n{\n  const vec3 s = vec3(1e0, 1e2, 1e4);\n  uv *= res;\n  vec3 uv0 = floor(mod(uv, res))*s;\n  vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n  vec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n  vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n  vec4 r = fract(sin(v*1e-3)*1e5);\n  float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n  float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  return mix(r0, r1, f.z)*2.-1.;\n}\nvoid main () {\n  freqs[0] = texture2D( texture2, vec2( 0.01, 0.25 ) ).x;\n  freqs[1] = texture2D( texture2, vec2( 0.07, 0.25 ) ).x;\n  freqs[2] = texture2D( texture2, vec2( 0.15, 0.25 ) ).x;\n  freqs[3] = texture2D( texture2, vec2( 0.30, 0.25 ) ).x;\n  float brightness  = freqs[1] * 0.25 + freqs[2] * 0.25;\n  float radius    = 0.24 + brightness * 0.2;\n  float invRadius   = 1.0/radius;\n  vec3 orange      = vec3( 0.8, 0.65, 0.3 );\n  vec3 orangeRed    = vec3( 0.8, 0.35, 0.1 );\n  float time    = cc_time.x * 0.1;\n  float aspect  = vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n  vec2 uv      = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n  vec2 p       = -0.5 + uv;\n  p.x *= aspect;\n  float fade    = pow( length( 2.0 * p ), 0.5 );\n  float fVal1    = 1.0 - fade;\n  float fVal2    = 1.0 - fade;\n  float angle    = atan( p.x, p.y )/6.2832;\n  float dist    = length(p);\n  vec3 coord    = vec3( angle, dist, time * 0.1 );\n  float newTime1  = abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n  float newTime2  = abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\n  for( int i=1; i<=7; i++ ){\n    float power = pow( 2.0, float(i + 1) );\n    fVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n    fVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n  }\n  float corona    = pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n  corona        += pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n  corona        *= 1.2 - newTime1;\n  vec3 sphereNormal   = vec3( 0.0, 0.0, 1.0 );\n  vec3 dir       = vec3( 0.0 );\n  vec3 center      = vec3( 0.5, 0.5, 1.0 );\n  vec3 starSphere    = vec3( 0.0 );\n  vec2 sp = -1.0 + 2.0 * uv;\n  sp.x *= aspect;\n  sp *= ( 2.0 - brightness );\n    float r = dot(sp,sp);\n  float f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n  if( dist < radius ){\n    corona      *= pow( dist * invRadius, 24.0 );\n      vec2 newUv;\n    newUv.x = sp.x*f;\n      newUv.y = sp.y*f;\n    newUv += vec2( time, 0.0 );\n    vec3 texSample   = texture2D( texture1, newUv ).rgb;\n    float uOff    = ( texSample.g * brightness * 4.5 + time );\n    vec2 starUV    = newUv + vec2( uOff, 0.0 );\n    starSphere    = texture2D( texture1, starUV ).rgb;\n  }\n  float starGlow  = min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n  gl_FragColor.rgb  = vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n  gl_FragColor.a    = 1.0;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nfloat freqs[4];\n#if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture1;\n  uniform sampler2D texture2;\n#endif\nfloat snoise(vec3 uv, float res)\n{\n  const vec3 s = vec3(1e0, 1e2, 1e4);\n  uv *= res;\n  vec3 uv0 = floor(mod(uv, res))*s;\n  vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n  vec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n  vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n  vec4 r = fract(sin(v*1e-3)*1e5);\n  float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n  float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  return mix(r0, r1, f.z)*2.-1.;\n}\nvoid main () {\n  freqs[0] = texture2D( texture2, vec2( 0.01, 0.25 ) ).x;\n  freqs[1] = texture2D( texture2, vec2( 0.07, 0.25 ) ).x;\n  freqs[2] = texture2D( texture2, vec2( 0.15, 0.25 ) ).x;\n  freqs[3] = texture2D( texture2, vec2( 0.30, 0.25 ) ).x;\n  float brightness  = freqs[1] * 0.25 + freqs[2] * 0.25;\n  float radius    = 0.24 + brightness * 0.2;\n  float invRadius   = 1.0/radius;\n  vec3 orange      = vec3( 0.8, 0.65, 0.3 );\n  vec3 orangeRed    = vec3( 0.8, 0.35, 0.1 );\n  float time    = cc_time.x * 0.1;\n  float aspect  = vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n  vec2 uv      = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n  vec2 p       = -0.5 + uv;\n  p.x *= aspect;\n  float fade    = pow( length( 2.0 * p ), 0.5 );\n  float fVal1    = 1.0 - fade;\n  float fVal2    = 1.0 - fade;\n  float angle    = atan( p.x, p.y )/6.2832;\n  float dist    = length(p);\n  vec3 coord    = vec3( angle, dist, time * 0.1 );\n  float newTime1  = abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n  float newTime2  = abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\n  for( int i=1; i<=7; i++ ){\n    float power = pow( 2.0, float(i + 1) );\n    fVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n    fVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n  }\n  float corona    = pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n  corona        += pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n  corona        *= 1.2 - newTime1;\n  vec3 sphereNormal   = vec3( 0.0, 0.0, 1.0 );\n  vec3 dir       = vec3( 0.0 );\n  vec3 center      = vec3( 0.5, 0.5, 1.0 );\n  vec3 starSphere    = vec3( 0.0 );\n  vec2 sp = -1.0 + 2.0 * uv;\n  sp.x *= aspect;\n  sp *= ( 2.0 - brightness );\n    float r = dot(sp,sp);\n  float f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n  if( dist < radius ){\n    corona      *= pow( dist * invRadius, 24.0 );\n      vec2 newUv;\n    newUv.x = sp.x*f;\n      newUv.y = sp.y*f;\n    newUv += vec2( time, 0.0 );\n    vec3 texSample   = texture2D( texture1, newUv ).rgb;\n    float uOff    = ( texSample.g * brightness * 4.5 + time );\n    vec2 starUV    = newUv + vec2( uOff, 0.0 );\n    starSphere    = texture2D( texture1, starUV ).rgb;\n  }\n  float starGlow  = min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n  gl_FragColor.rgb  = vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n  gl_FragColor.a    = 1.0;\n}"
      }
    }
  ],
  "subMetas": {}
}