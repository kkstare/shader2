{
  "ver": "1.0.27",
  "uuid": "75931ab4-2754-4fc2-8fec-5e8f7b5af749",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n    uniform sampler2D texture;\n    uniform sampler2D iChannel0;\n    uniform sampler2D iChannel1;\n    uniform sampler2D iChannel2;\n    uniform sampler2D iChannel3;\n  #endif\n  vec2 map( vec3 p )\n{\n    vec2 d2 = vec2( p.y+1.0, 2.0 );\n  float r = 1.0;\n  float f = smoothstep( 0.0, 0.5, sin(3.0+cc_time.x) );\n  float d = 0.5 + 0.5*sin( 4.0*p.x + 0.13*cc_time.x)*\n                    sin( 4.0*p.y + 0.11*cc_time.x)*\n                    sin( 4.0*p.z + 0.17*cc_time.x);\n    r += f*0.4*pow(d,4.0);\n    vec2 d1 = vec2( length(p) - r, 1.0 );\n    if( d2.x<d1.x) d1=d2;\n  p = vec3( length(p.xz)-2.0, p.y, mod(cc_time.x + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );\n    vec2 d3 = vec2( 0.5*(length(p) - 0.2), 3.0 );\n    if( d3.x<d1.x) d1=d3;\n  return d1;\n}\nvec4 sphereColor( in vec3 pos, in vec3 nor )\n{\n  vec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\nvec4 satelitesColor( in vec3 pos, in vec3 nor )\n{\n  vec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = 1.0;\n    return vec4( col, ao );\n}\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture2D( iChannel2, 0.5*pos.xz ).xyz;\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n  return vec4( col, 0.5*f+0.5*f*f );\n}\nconst float precis = 0.001;\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n  float h=precis*2.0;\n    vec3 c;\n    float t = 0.0;\n  float maxd = 9.0;\n    float sid = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\n        t += h;\n      vec2 res = map( ro+rd*t );\n        h = res.x;\n      sid = res.y;\n    }\n    if( t>maxd ) sid=-1.0;\n    return vec2( t, sid );\n}\n  vec3 calcNormal( in vec3 pos )\n  {\n      vec3  eps = vec3(precis,0.0,0.0);\n      vec3 nor;\n      nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n      nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n      nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n      return normalize(nor);\n  }\n  void main () {\n    vec2 q = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n    vec2 mo = vec2( cc_time.x , cc_time.x );\n    float an1 = 0.2*cc_time.x-6.2831*mo.x;\n    float an2 = clamp( 0.8 + 0.6*sin(2.2+cc_time.x*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n      vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n      vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n      vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n      vec3 vv = normalize(cross(ww,uu));\n      vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n      vec3 col = texture2D( iChannel0, rd ).xyz;\n      vec2 tmat = intersect(ro,rd);\n      if( tmat.y>0.5 )\n      {\n          vec3 pos = ro + tmat.x*rd;\n          vec3 nor = calcNormal(pos);\n          vec3 ref = reflect(rd,nor);\n      float rim = pow(clamp(1.0+dot(nor,rd),0.0,1.0),4.0);\n          col = texture2D( iChannel1, nor ).xyz;\n          vec4 mate = vec4(0.0);\n          if( tmat.y<1.5 )\n              mate = sphereColor(pos,nor);\n          else if( tmat.y<2.5 )\n              mate = floorColor(pos,nor);\n          else\n              mate = satelitesColor(pos,nor);\n          col += 2.0*rim*pow(mate.w,3.0);\n      col *= mate.w;\n      col *= mate.xyz;\n      vec2 tref = intersect(pos+nor*0.001,ref);\n      if( tref.y<0.5 )\n      {\n        float fre = 0.3 + 0.7*pow( clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 ), 5.0 );\n          vec3 sss = texture2D( iChannel0, ref ).xyz;\n          col += 2.0*mate.w*pow(sss,vec3(4.0))*fre;\n      }\n          col = sqrt(col);\n      }\n      col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n      gl_FragColor = vec4(col,1.0);\n  }"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n    uniform sampler2D texture;\n    uniform sampler2D iChannel0;\n    uniform sampler2D iChannel1;\n    uniform sampler2D iChannel2;\n    uniform sampler2D iChannel3;\n  #endif\n  vec2 map( vec3 p )\n{\n    vec2 d2 = vec2( p.y+1.0, 2.0 );\n  float r = 1.0;\n  float f = smoothstep( 0.0, 0.5, sin(3.0+cc_time.x) );\n  float d = 0.5 + 0.5*sin( 4.0*p.x + 0.13*cc_time.x)*\n                    sin( 4.0*p.y + 0.11*cc_time.x)*\n                    sin( 4.0*p.z + 0.17*cc_time.x);\n    r += f*0.4*pow(d,4.0);\n    vec2 d1 = vec2( length(p) - r, 1.0 );\n    if( d2.x<d1.x) d1=d2;\n  p = vec3( length(p.xz)-2.0, p.y, mod(cc_time.x + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );\n    vec2 d3 = vec2( 0.5*(length(p) - 0.2), 3.0 );\n    if( d3.x<d1.x) d1=d3;\n  return d1;\n}\nvec4 sphereColor( in vec3 pos, in vec3 nor )\n{\n  vec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\nvec4 satelitesColor( in vec3 pos, in vec3 nor )\n{\n  vec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = 1.0;\n    return vec4( col, ao );\n}\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture2D( iChannel2, 0.5*pos.xz ).xyz;\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n  return vec4( col, 0.5*f+0.5*f*f );\n}\nconst float precis = 0.001;\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n  float h=precis*2.0;\n    vec3 c;\n    float t = 0.0;\n  float maxd = 9.0;\n    float sid = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\n        t += h;\n      vec2 res = map( ro+rd*t );\n        h = res.x;\n      sid = res.y;\n    }\n    if( t>maxd ) sid=-1.0;\n    return vec2( t, sid );\n}\n  vec3 calcNormal( in vec3 pos )\n  {\n      vec3  eps = vec3(precis,0.0,0.0);\n      vec3 nor;\n      nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n      nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n      nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n      return normalize(nor);\n  }\n  void main () {\n    vec2 q = gl_FragCoord.xy / vec2(960.0,640.0).xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= vec2(960.0,640.0).x/vec2(960.0,640.0).y;\n    vec2 mo = vec2( cc_time.x , cc_time.x );\n    float an1 = 0.2*cc_time.x-6.2831*mo.x;\n    float an2 = clamp( 0.8 + 0.6*sin(2.2+cc_time.x*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n      vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n      vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n      vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n      vec3 vv = normalize(cross(ww,uu));\n      vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n      vec3 col = texture2D( iChannel0, rd ).xyz;\n      vec2 tmat = intersect(ro,rd);\n      if( tmat.y>0.5 )\n      {\n          vec3 pos = ro + tmat.x*rd;\n          vec3 nor = calcNormal(pos);\n          vec3 ref = reflect(rd,nor);\n      float rim = pow(clamp(1.0+dot(nor,rd),0.0,1.0),4.0);\n          col = texture2D( iChannel1, nor ).xyz;\n          vec4 mate = vec4(0.0);\n          if( tmat.y<1.5 )\n              mate = sphereColor(pos,nor);\n          else if( tmat.y<2.5 )\n              mate = floorColor(pos,nor);\n          else\n              mate = satelitesColor(pos,nor);\n          col += 2.0*rim*pow(mate.w,3.0);\n      col *= mate.w;\n      col *= mate.xyz;\n      vec2 tref = intersect(pos+nor*0.001,ref);\n      if( tref.y<0.5 )\n      {\n        float fre = 0.3 + 0.7*pow( clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 ), 5.0 );\n          vec3 sss = texture2D( iChannel0, ref ).xyz;\n          col += 2.0*mate.w*pow(sss,vec3(4.0))*fre;\n      }\n          col = sqrt(col);\n      }\n      col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n      gl_FragColor = vec4(col,1.0);\n  }"
      }
    }
  ],
  "subMetas": {}
}