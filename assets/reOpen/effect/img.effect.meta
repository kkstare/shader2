{
  "ver": "1.0.27",
  "uuid": "155095cb-69f1-42e0-b65f-6a56880b3a20",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n    #if IS_SHADOW\n      pos.y = pos.y*2.0;\n    #endif\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform vec2 size;\n  #if IS_CUT\n      uniform float cutValue;\n  #endif\n  #if IS_FLUXAY\n     uniform vec4 fluaxyColor;\n  #endif\n  #if IS_BLUR\n      uniform float radius;\n  #endif\n  #if IS_NOISE\n  #endif\n  #if IS_FUSE\n        uniform sampler2D texture3;\n  #endif\n  #if IS_WATER\n  #endif\n  #if IS_SHADOW\n  #endif\n  #if IS_CIRCLE\n      uniform float circleRadius;\n  #endif\n  #if IS_POLYGON\n    uniform sampler2D texture_polygon;\n  #endif\n  #if IS_TIGER\n  #endif\n#endif\nvec4 getBlurColor (vec2 pos ) {\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  const float RADIUS = 20.0;\n  vec2 size = vec2(500,417);\n  for (float r = -RADIUS; r <= RADIUS; r++) {\n    for (float c = -RADIUS; c <= RADIUS; c++) {\n      if( abs(r) < radius  && abs(c) < radius ){\n        vec2 target = pos + vec2(r / size.x, c / size.y);\n        float weight = (RADIUS - abs(r)) * (RADIUS - abs(c));\n        color += texture2D(texture, target) * weight;\n        sum += weight;\n      }\n    }\n  }\n  color /= sum;\n  return color;\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec2 uv = v_uv0;\n  vec4 a_color = v_color;\n  vec4 a = vec4(1,1,1,1);\n  #if USE_TEXTURE\n    o*=texture2D(texture,uv);\n    #if IS_CUT\n      if(o.r >cutValue && o.b>cutValue && o.g>cutValue ) {\n          discard;\n      }\n    #endif\n    #if IS_FLUXAY\n        if(  abs( tan(cc_time.x) - (uv.x+uv.y)/2.0 ) <0.02 ) {\n            a_color = fluaxyColor;\n          }\n    #endif\n    #if IS_BLUR\n      o = vec4(1,1,1,1);\n      a_color = getBlurColor(uv);\n    #endif\n    #if IS_NOISE\n        a = vec4(1,1,1,1);\n        a*=texture2D(texture2,uv);\n        if(a.r< abs(sin(cc_time.x)) ) {\n          discard;\n        }\n    #endif\n    #if IS_FUSE\n        o = vec4(1,1,1,1);\n        a = vec4(1,1,1,1);\n        a*=texture2D(texture3,uv);\n        float x = sin(cc_time.x);\n        if( a.b> x && a.g>x && a.r >x ){\n          o*=texture2D(texture,uv );\n        }else{\n          o*=texture2D(texture3,uv  );\n        }\n    #endif\n    #if IS_WATER\n        o = vec4(1,1,1,1);\n      if(uv.y > 0.4 + sin(uv.x * 12.35+ cc_time.x)*0.02 ) {\n           uv.y = uv.y+ sin(uv.x*12.35+ cc_time.x)*0.02;\n           vec4 waterColor = vec4(2,199,255,255);\n            a_color = (normalize(waterColor)+a_color)/2.0;\n        }\n        o*=texture2D(texture,uv );\n    #endif\n    #if IS_SHADOW\n      o = vec4(1,1,1,1);\n      if(uv.y<=0.5) {\n        uv.y = uv.y *2.0;\n      }else{\n        uv.y = (1.0- uv.y)*2.0;\n      }\n      o*=texture2D(texture,uv );\n    #endif\n    #if IS_CIRCLE\n      float dis =  distance(uv*size,vec2(0.5,0.5)*size );\n      if(dis>circleRadius){\n        discard;\n      }\n    #endif\n    #if IS_POLYGON\n        a = vec4(1,1,1,1);\n        o = vec4(1,1,1,1);\n        a *= texture2D(texture_polygon,uv);\n        a *= texture2D(texture,uv);\n        float x_POLYGON = 0.05;\n        if( a.b<x_POLYGON && a.r<x_POLYGON && a.g<x_POLYGON){\n          o*= texture2D(texture,uv );\n        }else{\n          discard;\n        }\n    #endif\n  #endif\n  o *= a_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n    #if IS_SHADOW\n      pos.y = pos.y*2.0;\n    #endif\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform common{\n  vec2 size;\n};\n  #if IS_CUT\n      uniform cut{\n        float cutValue;\n      };\n  #endif\n  #if IS_FLUXAY\n     uniform fluaxy{\n        vec4 fluaxyColor;\n      };\n  #endif\n  #if IS_BLUR\n      uniform buur{\n        float radius;\n      };\n  #endif\n  #if IS_NOISE\n  #endif\n  #if IS_FUSE\n        uniform sampler2D texture3;\n  #endif\n  #if IS_WATER\n  #endif\n  #if IS_SHADOW\n  #endif\n  #if IS_CIRCLE\n      uniform circle{\n        float circleRadius;\n      };\n  #endif\n  #if IS_POLYGON\n    uniform sampler2D texture_polygon;\n  #endif\n  #if IS_TIGER\n    uniform tiger{\n      float maxLength;\n      float number;\n      float dirction;\n      float offset;\n    };\n  #endif\n#endif\nvec4 getBlurColor (vec2 pos ) {\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  const float RADIUS = 20.0;\n  vec2 size = vec2(500,417);\n  for (float r = -RADIUS; r <= RADIUS; r++) {\n    for (float c = -RADIUS; c <= RADIUS; c++) {\n      if( abs(r) < radius  && abs(c) < radius ){\n        vec2 target = pos + vec2(r / size.x, c / size.y);\n        float weight = (RADIUS - abs(r)) * (RADIUS - abs(c));\n        color += texture2D(texture, target) * weight;\n        sum += weight;\n      }\n    }\n  }\n  color /= sum;\n  return color;\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec2 uv = v_uv0;\n  vec4 a_color = v_color;\n  vec4 a = vec4(1,1,1,1);\n  #if USE_TEXTURE\n    o*=texture(texture,uv);\n    #if IS_CUT\n      if(o.r >cutValue && o.b>cutValue && o.g>cutValue ) {\n          discard;\n      }\n    #endif\n    #if IS_FLUXAY\n        if(  abs( tan(cc_time.x) - (uv.x+uv.y)/2.0 ) <0.02 ) {\n            a_color = fluaxyColor;\n          }\n    #endif\n    #if IS_BLUR\n      o = vec4(1,1,1,1);\n      a_color = getBlurColor(uv);\n    #endif\n    #if IS_NOISE\n        a = vec4(1,1,1,1);\n        a*=texture(texture2,uv);\n        if(a.r< abs(sin(cc_time.x)) ) {\n          discard;\n        }\n    #endif\n    #if IS_FUSE\n        o = vec4(1,1,1,1);\n        a = vec4(1,1,1,1);\n        a*=texture(texture3,uv);\n        float x = sin(cc_time.x);\n        if( a.b> x && a.g>x && a.r >x ){\n          o*=texture(texture,uv );\n        }else{\n          o*=texture(texture3,uv  );\n        }\n    #endif\n    #if IS_WATER\n        o = vec4(1,1,1,1);\n      if(uv.y > 0.4 + sin(uv.x * 12.35+ cc_time.x)*0.02 ) {\n           uv.y = uv.y+ sin(uv.x*12.35+ cc_time.x)*0.02;\n           vec4 waterColor = vec4(2,199,255,255);\n            a_color = (normalize(waterColor)+a_color)/2.0;\n        }\n        o*=texture(texture,uv );\n    #endif\n    #if IS_SHADOW\n      o = vec4(1,1,1,1);\n      if(uv.y<=0.5) {\n        uv.y = uv.y *2.0;\n      }else{\n        uv.y = (1.0- uv.y)*2.0;\n      }\n      o*=texture(texture,uv );\n    #endif\n    #if IS_CIRCLE\n      float dis =  distance(uv*size,vec2(0.5,0.5)*size );\n      if(dis>circleRadius){\n        discard;\n      }\n    #endif\n    #if IS_POLYGON\n        a = vec4(1,1,1,1);\n        o = vec4(1,1,1,1);\n        a *= texture(texture_polygon,uv);\n        a *= texture(texture,uv);\n        float x_POLYGON = 0.05;\n        if( a.b<x_POLYGON && a.r<x_POLYGON && a.g<x_POLYGON){\n          o*= texture(texture,uv );\n        }else{\n          discard;\n        }\n    #endif\n  #endif\n  o *= a_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n}"
      }
    }
  ],
  "subMetas": {}
}